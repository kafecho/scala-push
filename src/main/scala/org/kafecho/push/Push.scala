/*
 * Copyright 2009 Guillaume Belrose
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and limitations under the License.
*/
package org.kafecho.push

import scala.xml.XML
import scala.xml.Elem

import org.apache.commons.codec.digest.DigestUtils

import org.restlet.{Client,Component,Restlet};
import org.restlet.data._

import java.io.FileNotFoundException
import java.util.logging.LogManager

/**
 * A Scala singleton object with String constants used by the PubSubHubBub protocol
 */
object Constants{
    val callback= "hub.callback"
    val mode	= "hub.mode"
    val subscribe ="subscribe"
    val unsubscribe ="unsubscribe"
    val topic 	= "hub.topic"
    val verify 	= "hub.verify"
    val lease_seconds = "hub.lease_seconds"
    val secret  = "hub.secret"
    val verify_token = "hub.verify_token"
    val sync  = "sync"
    val async = "async"
    val challenge = "hub.challenge"
}

/**
 * case class containing information about a PubSubHubBub enabled feed.
 * I use a case class so that:
 * -no need to use the new keyword when creating instances.
 * -toString method is auto-generated by the compiler.
 */
case class Feed(val topicURL : String, val hubURL : String, title : String){
  val id = DigestUtils.md5Hex(topicURL)
  // Serialize the feed information to XML.
  def toXML = <feed><id>{id.toString}</id><title>{title}</title><topicURL>{topicURL}</topicURL><hubURL>{hubURL}</hubURL></feed>
}

/*
 * Class that implements a PubSubHubBub subscriber.
 * The subscriber implements the PubSubHubBub REST API and an admin REST API to configure it.
 * You must provide the hostname and portnumber of the host on which the subscriber will be running.
 * The host MUST be recheable from the Internet for the PubSubHubBub protocol to work.
*/
class Subscriber(val hostname:String, val port : Int) extends Logging{

  val httpClient = new Client(Protocol.HTTP);
  val pushRoute		= "push"
  val adminRoute 	= "admin"
  val callbackRoute   = "http://" + hostname + ":" + port + "/" + pushRoute 
  val pushRestlet 	= new PuSHRestlet(this)
  val adminRestlet 	= new AdminRestlet(this)
  val configFile	= "feeds.xml"
  var pendingSubscriptions : Set[Feed] = Set()
  var activeSubscriptions : Set[Feed] = Set()
  
  val root : Component = new Component  
  root.getLogService.setEnabled(false)
  root.getServers.add(Protocol.HTTP, port)
  root.getDefaultHost.attach("/" + pushRoute + "/{ID}",pushRestlet)
  root.getDefaultHost.attach("/" + adminRoute + "/{ID}",adminRestlet)
  root.getDefaultHost.attach("/" + adminRoute + "/",adminRestlet)
  root.start

  loadConfig
  
  def loadConfig{
    try{
    	val config = XML.loadFile(configFile)
    	(config\"feed").foreach{t => subUnsub( Feed( t \ "topicURL" text, t \ "hubURL" text, t \ "title" text) ,true) }
    }catch{
      case ex: FileNotFoundException => 
    }
 }

  /**
   * Discover PubSubHubBub protocol information from an Atom feed.
   * Return an optional Feed object containing one of the hub URLs and the topic URL or nothing is the feed doed not support PubSubHubBub.
   */
  def discover( atomURL : String) : Option[Feed] = {
    val response = httpClient.handle(new Request( Method.GET,atomURL))
    if (response.getStatus.isSuccess){
      val xml = XML.load (response.getEntity.getStream)
      // Look for xml nodes containing a hub URL and a topic URL
      val nodes = List("self","hub").map (v => xml \"link" find ( _\"@rel" == v)) 
      (nodes) match {
        case List(Some(selfNode),Some(hubNode)) => Some( Feed (selfNode \ "@href" text , hubNode \ "@href" text , xml \ "title" text))
        case _ => None
      }
    }
    else None
  }
  
  /**
   * Subscribe or unsubscribe to a feed given its URL. 
   * Will complain if the feed is not PubSubHubBub enabled.
   */
  def subUnsub (feedURL : String, flag : Boolean){
     discover(feedURL) match{
      case Some(feed) => subUnsub(feed,flag)
      case None => log.error("Unable to fetch the hub or topic URL from the feed " + feedURL)
	}
  }
  
  /**
   * Subscribe or unsubscribe to a PuSH enabled feed.
   */
  def subUnsub(feed : Feed, flag : Boolean){
	  log.info("Feed: " + feed + ", subscribe? " + flag)
	  pendingSubscriptions = pendingSubscriptions + feed
	  val callbackURL = callbackRoute + "/" + feed.id
	  val mode = if (flag) Constants.subscribe else Constants.unsubscribe
	  issueRequest(feed.topicURL,feed.hubURL,callbackURL,mode)
  }

  /**
   * Send a request to the hub to subscribe or unsubscribe a feed.
   */
  private def issueRequest(topicURL : String, hubURL : String, callbackURL : String, mode : String){
	  val form = new Form
	  form.add(Constants.topic,topicURL)
	  form.add(Constants.mode, mode )
	  form.add(Constants.callback,callbackURL )
	  form.add(Constants.verify,Constants.sync)
	  val response  = httpClient.handle(new Request(Method.POST,hubURL,form.getWebRepresentation))
	  if (!response.getStatus.isSuccess) log.error("Unable to " + mode + " to topic " + topicURL + ", HTTP status: " + response.getStatus.toString)
  }
  
  /**
   * Method used for garbage collection of subscriptions.
   */
  def purge(topicURL : String, hubURL : String,callbackURL : String) = issueRequest(topicURL, hubURL, callbackURL, Constants.unsubscribe)
    
  /**
   * Notification that a hub has accepted a request to subscribe to a feed.
   */
  def subscribed (topicURL : String){
	  val found = pendingSubscriptions.find (_.topicURL == topicURL)
	  found match{
	    case Some(subscription) =>
	      activeSubscriptions = activeSubscriptions + subscription
       	  saveSubscriptions
	    case _ => log.warn("Mmm, unrecognized feed: " + topicURL)
	  }
  }

  /**
   * Notification that a hub has accepted a request to unsubscribe from a feed.
   */
  def unsubscribed (topicURL : String){
	  activeSubscriptions = activeSubscriptions.filter( _.topicURL != topicURL)
	  saveSubscriptions
  }
  
	/*
	* Notication of content publication from a hub.
	*/
	def contentPublished(atom : Elem){
		val Some(topicNode) = (atom\"link").find( _\"@rel" == "self")
		println (RFC3339.parse((atom\"updated").text) + " --- Update from: " + (atom\"title").text )
		println ("Topic URL: " + topicNode\"@href" + "\n")
  
		(atom\"entry").foreach{ e=>
			val link = (e\"link").find( _\"@rel" == "alternate").get\"@href"
			val entryTitle = (e\"title").text
			val entryPublished = (e\"published").text
			println (entryTitle + " (published " + RFC3339.parse(entryPublished) + ")\n" + link + "\n")
		}
	}

  def saveSubscriptions : Unit = XML.saveFull(configFile, subscriptionsToXML , "UTF-8",true, null)
  
  def subscriptionsToXML= <feeds>{activeSubscriptions.map(_.toXML)}</feeds>
}	

/**
 * Main.
 */
object Main {
	def main ( args: Array[String]) : Unit = {
	  if (args.length != 2){
		System.err.println("Please specify a hostname and a port number.")  
	    exit(-1)
	  }else{
		LogManager.getLogManager.readConfiguration(getClass.getResourceAsStream("/log.properties"))
		new Subscriber(args(0), args(1).toInt)
		println ("The subscriber service is up.")
		println ("The HTTP admin interface is running @ http://" + args(0) +":" + args(1) + "/admin/")
	  } 
	}
}


